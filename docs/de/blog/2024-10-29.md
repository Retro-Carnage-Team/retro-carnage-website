# Automatisierung des Release-Prozesses

üìÖ *2024-10-29* - üßî Thomas

Seit ich im M√§rz angefangen habe wieder regelm√§√üiger an Retro Carnage zu arbeiten, habe ich einmal pro Monat ein Pre-Release [ver√∂ffentlicht](https://github.com/Retro-Carnage-Team/retro-carnage/tags). Die jeweiligen St√§nde des Spiels habe ich dann zum Beispiel Freunden und Kollegen gezeigt, um Feedback zu einzelnen Features einzuholen.

Das Erstellen dieser Releases war bislang ein manueller Prozess, dessen Durchf√ºhrung zwei Computer notwendig machte und insgesamt rund eine Stunde gedauert hat. Der Ablauf umfasste grob folgende Schritte:

-  Erstellen des Tags √ºber die GitHub-Website
-  Download des Quelltextes und der Assets jeweils auf Windows und Linux
-  Kompilieren des Quelltextes und Erstellen einer Archiv-Datei
-  Upload der Archiv-Datei auf die Website und Aktualisieren der Links

## √úber GitHub Actions

Der Quelltext von [Retro Carnage wird auf GitHub verwaltet](https://github.com/Retro-Carnage-Team/retro-carnage). GitHub bietet mit [GitHub Actions](https://github.com/features/actions) eine tolle M√∂glichkeit zur Automatisierung. GitHub Actions k√∂nnen durch verschiedene Ereignisse des Quelltext-Repositories angesto√üen werden, etwa durch neue Pull-Requests oder Pushes in bestimmte Branches. Anfangs hatte ich solche Automatisierungen durch lokale Scripts erledigt, was f√ºr mich einfacher war und keine Einarbeitung erforderte. Nach und nach habe ich diese Scripts dann durch GitHub Actions ersetzt, weil mich gerade das Zusammenspiel der Actions mehr und mehr √ºberzeugte.

Insgesamt waren die einzelnen Actions, die ich bislang verwendet habe, jedoch ziemlich einfach. Da ich mich aktuell beruflich mit DevSecOps besch√§ftige, dachte ich es w√§re eine gute Gelegenheit mich eingehender mit den M√∂glichkeiten von GitHub Actions zu besch√§ftigen und das Gelernte direkt auf den Release-Prozess von Retro Carnage anzuwenden. Dazu habe ich den manuellen Release-Prozess [automatisiert](https://github.com/Retro-Carnage-Team/retro-carnage/blob/main/.github/workflows/release.yml). 

## Umsetzung des Release-Prozesses

Den Release-Ablauf habe ich in einer Actions mit zwei Jobs definiert. Die beiden Jobs habe ich Runnern mit unterschiedlichen Betriebssystemen zugewiesen. Ein Job erstellt damit das Linux-Relase, ein anderer Job das Windows-Release. F√ºr mich war √ºberraschend, wie einfach dabei die Arbeit mit dem Windows-Runner (windows-latest) ist. Meine Erwartungshaltung war, dass die Einrichtung des Windows-Runners mit den notwendigen Build-Tools zeitaufw√§ndig und kompliziert sein w√ºrde. Tats√§chlich waren aber schon [alle m√∂glichen](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md) (und von Retro Carnage ben√∂tigten) Build-Tools auf dem Runner eingerichtet. Zum Beispiel war schon ein C++-Compiler vorinstalliert, mit dem die Erstellung der Go-Bindings f√ºr OpenGL direkt m√∂glich war.

Die Jobs kompilieren den Quelltext, f√ºhren die ausf√ºhrbare Programmdatei mit den [Assets des Spiels](https://github.com/Retro-Carnage-Team/retro-carnage-assets) zusammen und erstellen daraus eine Archiv-Datei. Die Archiv-Dateien werden dann per SFTP auf den Web-Server √ºbertragen, von wo User sie downloaden k√∂nnen. Die Logik f√ºr den Upload ist in der Action definiert. Die notwendigen [Credentials sind von der Action getrennt](https://docs.github.com/de/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions) in GitHub hinterlegt und werden √ºber Variablen eingebunden.

Den Upload habe ich unter Windows und Linux unterschiedlich gel√∂st. Die Linux-Version habe ich zuerst umgesetzt und dazu lftp genutzt. F√ºr die Windows-Version habe ich die [SFTP Upload Action](https://github.com/marketplace/actions/sftp-upload) vom GitHub-Marktplatz verwendet. Ein wenig Bauchschmerzen macht mir, dass die Actions auf dem Marktplatz nicht weiter gepr√ºft werden. Man muss dem Autor der Erweiterung also schon ziemliches Vertrauen entgegenbringen - insbesondere, wenn man der Erweiterung Credentials √ºbergibt. Vielleicht w√§re ein Fork der Action eine gute M√∂glichkeit um Kontrolle √ºber die Erweiterung zu behalten... Das muss ich mir in den n√§chsten Tagen mal n√§her anschauen.
